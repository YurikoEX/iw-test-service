
import domain = require('domain');

import _ = require('lodash');
import async = require('async');

import idHelper = require('../../src/helpers/idHelper');

import Comm = require('../../src/eventing/Comm');
import IComm = require('../../interfaces/eventing/IComm');
import ICommOpts = require('../../interfaces/opts/ICommOpts');
import Collection = require('../../src/collection/Collection');
import ICollection = require('../../interfaces/collection/ICollection');
import IWorkerChild = require('../../interfaces/workers/IWorkerChild');
import IWorker = require('../../interfaces/workers/IWorker');
import IWorkerOpts = require('../../interfaces/opts/IWorkerOpts');
import IWhoQuery = require('../../interfaces/whoIAm/IWhoQuery');
import IDependency = require('../../interfaces/workers/IDependency');
import IAm = require('../../interfaces/whoIAm/IAm');
import IServiceReady = require('../../interfaces/service/IServiceReady');

import Worker = require('../workers/Worker');

import IService = require('../../interfaces/service/IService');
import IServiceOpts = require('../../interfaces/opts/IServiceOpts');

class Service extends Worker implements IService {
    private workers: ICollection<IWorkerChild>;

    constructor(name: string, opts?: IServiceOpts) {
        var id = idHelper.newId();

        var defWorkerName = 'service-as-a-worker';

        super([], void 0, void 0, {
            id: id,
            name: _.isUndefined(opts) || _.isUndefined(opts.workerName) ? defWorkerName : opts.workerName
        });

        var defOpts: IServiceOpts = {
            dependencyCheckTimeout: 120000,
            dependencyCheckFrequency: 100,
            server: {
                port: 8080
            },
            workerName: defWorkerName
        };
        this.opts = this.opts.beAdoptedBy<IServiceOpts>(defOpts, 'worker');
        this.opts.merge(opts);

        this.workers = new Collection<IWorkerChild>(idHelper.newId());

        this.service = {
            id: id,
            name: name
        };

        this.comm = new Comm(this.service, {
            id: idHelper.newId(),
            name: name + '-comm'
        }, this.opts.get<string>('workerName'), this.opts.get<ICommOpts>('comm'));
    }

    public start(callback?: (e: Error) => void) {
        var instance: Service = this;
        async.waterfall([
            (commStarted) => {
                instance.comm.start(commStarted);
            },
            (workersStarted) => {
                instance.workers.each((worker: IWorkerChild, workerStarted: (e: Error) => void) => {
                    instance.readyWorker(worker, workerStarted);
                }, workersStarted);
            }
        ], (e: Error) => {
            if (!_.isUndefined(callback)) {
                callback(e);
            }
            instance.running = true;
            if (e === null) {
                instance.inform<IServiceReady>('ready', {
                    service: instance
                });
            }
            else {
                instance.inform('error', e);
            }
        });
    }

    private readyWorker(worker: IWorkerChild, workerStarted?: (e: Error) => void) {
        var instance = this;
        var errorPrefix = 'Failed to load dependencies for ' + worker.who().name + ': ';
        async.waterfall([
            (workerInited) => {
                worker.init(workerInited);
            },
            (workerDepsLoaded) => {
                var depNames = worker.getDependencyNames();
                if (depNames.length > 0) {
                    instance.workers.get({
                        names: depNames
                    }, (e: Error, deps: ICollection<IWorkerChild>) => {
                        if (deps.length() < depNames.length) {
                            workerDepsLoaded(new Error(errorPrefix + 'missing - ' +
                                _.difference(depNames, _.pluck(deps.list(), 'name')).join(', ')
                            ));
                        }
                        else {
                            workerDepsLoaded(null, deps);
                        }
                    });
                }
                else {
                    workerDepsLoaded(null, new Collection<IWorkerChild>(idHelper.newId()));
                }
            },
            (workerDeps, allDepsStarted) => {
                var started = new Date().getTime();
                var timeout = instance.opts.get<number>('dependencyCheckTimeout');
                async.whilst(() => {
                    return !_.every(workerDeps.list(), (w: IWorkerChild) => {
                        return w.running;
                    });
                }, (tryAgain) => {
                    var now = new Date().getTime();
                    if ((now - started) >= timeout) {
                        tryAgain(new Error(errorPrefix + 'timeout'));
                    }
                    else {
                        setTimeout(tryAgain, instance.opts.get<number>('dependencyCheckFrequency'));
                    }
                }, (e: Error) => {
                    allDepsStarted(e, workerDeps);
                });
            },
            (workerDeps, workerReady) => {
                worker.start(workerDeps, (e: Error) => {
                    if (e === null) {
                        worker.running = true;
                    }
                    workerReady(e);
                });
            }
        ], workerStarted);
    }

    public who(callback?: (e: Error, me: IAm) => void): IAm {
        var iam = this.service;
        if (!_.isUndefined(callback)) {
            process.nextTick(() => {
                callback(null, iam);
            });
        }
        return iam;
    }

    public use(worker: IWorkerChild): IService {
        this.workers.add(worker);
        return this;
    }

    public inject(injector: (service: IService, use: (worker: IWorkerChild) => void) => void)
    : IService {
        var instance = this;
        injector.call(this, this, (worker: IWorkerChild) => {
            instance.use.call(instance, worker);
        });
        return this;
    }

    public get(workerQuery: IWhoQuery, callback: (e: Error, results: ICollection<IWorkerChild>) => void): IService {
        this.workers.get(workerQuery, callback);
        return this;
    }

    public getLastEvent(): string {
        return this.comm.getLastEvent();
    }

    public disposeWorkers(callback: () => void) {
        var instance = this;
        async.series([
            (cb: (e: Error) => void) => {
                async.each(this.workers.list(), (w: IWorkerChild, wcb: () => void) => {
                    w.dispose(wcb);
                }, cb);
            },
            (cb: () => void) => {
                instance.workers.dispose(cb);
            },
            (cb: () => void) => {
                instance.comm.dispose(cb);
            }
        ], callback);
    }

    public dispose(callback?: () => void) {
        this.disposeWorkers(() => {
            super.dispose(callback);
        });
    }
}

export = Service;
