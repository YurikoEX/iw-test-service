
import events = require('eventemitter2');
import _ = require('lodash');

import idHelper = require('../helpers/idHelper');
import IEvent = require('../../interfaces/eventing/IEvent');
import Event = require('./Event');
import IEmit = require('../../interfaces/eventing/IEmit');
import IAm = require('../../interfaces/whoIAm/IAm');
import IInterceptor = require('../../interfaces/eventing/IInterceptor');
import Collection = require('../collection/Collection');
import ICollection = require('../../interfaces/collection/ICollection');

import Options = require('../opts/Options');

import IEventer = require('../../interfaces/eventing/IEventer');
import IEventerOpts = require('../../interfaces/opts/IEventerOpts');

class Eventer extends events.EventEmitter2 implements IEventer {
    private useOnce: boolean;

    protected interceptors: ICollection<IInterceptor>;
    protected event: string;
    protected opts: Options<IEventerOpts>;

    constructor(opts?: IEventerOpts) {

        var defOpts: IEventerOpts = {
            eventEmitter2Config: {
                wildcard: true
            }
        };
        this.opts = new Options<IEventerOpts>(defOpts);
        this.opts.merge(opts);

        super(this.opts.get('eventEmitter2Config'));

        this.useOnce = false;

        this.event = "";
    }

    public getLastEvent(): string {
        return this.event;
    }


    private static getEvent(event: IEvent|string): IEvent {
        if (typeof event === 'string') {
            return new Event({
                name: event
            });
        }
        return <IEvent>event;
    }
    

    public tell(event: IEmit|string): boolean {
        var evt = Eventer.getEvent(event);
        return this.emit(evt.getText(), evt);
    }

    public inform<infoType>(event: IEmit|string, info: infoType): boolean {
        var evt = Eventer.getEvent(event);
        return this.emit(evt.getText(), evt, info);
    }

    public confirm(event: IEmit|string, callback: (e: Error) => void): boolean {
        var evt = Eventer.getEvent(event);
        return this.emit(evt.getText(), evt, callback);
    }

    public ask<answerType>(event: IEmit|string, callback: (e: Error, answer?: answerType) => void): boolean {
        var evt = Eventer.getEvent(event);
        return this.emit(evt.getText(), evt, callback);
    }

    public request<requestType, responseType>(
        event: IEmit|string, request: requestType, callback: (e: Error, response?: responseType) => void)
    : boolean {
        var evt = Eventer.getEvent(event);
        return this.emit(evt.getText(), evt, request, callback);
    }


    public listen(event: IEvent|string, listener: () => void): IEventer {
        return this.setupListener(event, listener);
    }

    public info<infoType>(event: IEvent|string, listener: (info: infoType) => void): IEventer {
        return this.setupListener(event, listener);
    }

    public ack(event: IEvent|string, listener: (callback: (e: Error) => void) => void): IEventer {
        return this.setupListener(event, listener);
    }

    public answer<answerType>(
        event: IEvent|string, listener: (callback: (e: Error, answer?: answerType) => void) => void)
    : IEventer {
        return this.setupListener(event, listener);
    }

    public respond<requestType, responseType>(
        event: IEvent|string, 
        listener: (request: requestType, callback: (e: Error, response?: responseType) => void) => void)
    : IEventer {
        return this.setupListener(event, listener);
    }

    public onlyOnce(): IEventer {
        this.useOnce = true;
        return this;
    }

    private setupListener(event: IEvent|string, listener: Function) {
        var evt = Eventer.getEvent(event);
        var method = this.getListenMethod();
        var instance = this;
        method.call(this, evt.getText(), (emit: IEmit, ...args: any[]) => {
            instance.interceptListener(listener, emit, args);
        });
        return this;
    }

    private interceptListener(listener: Function, emit: IEmit, args: any[]) {
        if (_.isUndefined(this.interceptors)) {
            this.interceptors = new Collection<IInterceptor>(idHelper.newId());
        }
        var instance = this;
        this.interceptors.get({
            names: [ emit.getText() ]
        }, (e: Error, interceptors: ICollection<IInterceptor>) => {
            if (interceptors.length() === 0) {
                listener.apply(instance, args);
            }
            else {
                console.log();
            }
        });
    }

    private getListenMethod(): Function {
        if (this.useOnce) {
            this.useOnce = false;
            return this.once;
        }
        return this.on;
    }

    public dispose(callback?: () => void) {
        //TODO
        if (!_.isUndefined(callback)) {
            process.nextTick(() => {
                callback();
            });
        }
    }
}

export = Eventer;
