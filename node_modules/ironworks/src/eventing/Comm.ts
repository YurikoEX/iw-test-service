
import _ = require('lodash');

import idHelper = require('../helpers/idHelper');

import IAm = require('../../interfaces/whoIAm/IAm');
import CommEvent = require('./CommEvent');
import ICommEvent = require('../../interfaces/eventing/ICommEvent');
import ICommEventData = require('../../interfaces/eventing/ICommEventData');
import ICommEmit = require('../../interfaces/eventing/ICommEmit');
import IDependency = require('../../interfaces/workers/IDependency');
import ICollection = require('../../interfaces/collection/ICollection');
import IWorkerChild = require('../../interfaces/workers/IWorkerChild');
import IInterceptor = require('../../interfaces/eventing/IInterceptor');
import Interceptor = require('./Interceptor');

import Eventer = require('./Eventer');

import IComm = require('../../interfaces/eventing/IComm');
import ICommOpts = require('../../interfaces/opts/ICommOpts');

class Comm extends Eventer implements IComm {
    private service: IAm;
    private serviceWorkerName: string;
    private me: IAm;

    public running: boolean;

    constructor(service: IAm, whoAmI: IAm, serviceWorkerName: string, opts?: ICommOpts) {
        super();

        this.service = service;
        this.serviceWorkerName = serviceWorkerName;

        var defOpts: ICommOpts = {
            prefix: 'comm'
        };
        this.opts = this.opts.beAdoptedBy<ICommOpts>(defOpts, 'eventer');
        this.opts.merge(opts);

        this.me = whoAmI;
        this.running = false;

        this.ack('dispose', this.dispose);
    }

    public init(callback: (e: Error) => void) {
        process.nextTick(() => {
            callback(null);
        });
    }

    public start(callback?: (e: Error) => void) {
        this.running = true;
        if (!_.isUndefined(callback)) {
            process.nextTick(() => {
                callback(null);
            });
        }
    }

    public prefix(): string {
        return this.opts.get<string>('prefix');
    }

    public who(callback?: (e: Error, me: IAm) => void): IAm {
        var iam = this.me;
        if (!_.isUndefined(callback)) {
            process.nextTick(() => {
                callback(null, iam);
            });
        }
        return iam;
    }

    public getDependencyNames(): string[] {
        return [];
    }

    public getComm(): IComm {
        return this;
    }


    private getCommEvent(event: ICommEvent|string, method?: string): ICommEvent {
        if (typeof event === 'string') {
            return new CommEvent({
                prefix: this.prefix(),
                service: this.service.name,
                method: method,
                worker: this.serviceWorkerName,
                name: event
            });
        }
        return <ICommEvent>event;
    }

    private getEmit(event: ICommEmit|string, method?: string): ICommEmit {
        if (typeof event === 'string') {
            var evt = <ICommEmit>this.getCommEvent(event, method);
            if (_.isUndefined(evt.id)) {
                evt.id = idHelper.newId();
            }
            if (_.isUndefined(evt.emitter)) {
                evt.emitter = this.me;
            }
        }
        return <ICommEmit>event;
    }


    public tell(event: ICommEmit|string): boolean {
        var emit = this.getEmit(event, 'tell');
        return super.tell(emit);
    }

    public inform<infoType>(event: ICommEmit|string, info: infoType): boolean {
        var emit = this.getEmit(event, 'inform');
        return super.inform<infoType>(emit, info);
    }

    public confirm(event: ICommEmit|string, callback: (e: Error) => void): boolean {
        var emit = this.getEmit(event, 'confirm');
        return super.confirm(emit, callback);
    }

    public ask<answerType>(event: ICommEmit|string, callback: (e: Error, answer?: answerType) => void): boolean {
        var emit = this.getEmit(event, 'ask');
        return super.ask<answerType>(emit, callback);
    }

    public request<requestType, responseType>(
        event: ICommEmit|string, request: requestType, callback: (e: Error, response?: responseType) => void)
    : boolean {
        var emit = this.getEmit(event, 'request');
        return super.request<requestType, responseType>(emit, request, callback);
    }


    public intercept(event: ICommEventData|string): IInterceptor {
        var i = new Interceptor(this, event);
        this.interceptors.add(i);
        return i;
    }


    public listen(event: ICommEvent|string, listener: () => void): IComm {
        var evt = this.getCommEvent(event, 'tell');
        super.listen(evt, listener);
        return this;
    }

    public info<infoType>(event: ICommEvent|string, listener: (info: infoType) => void): IComm {
        var evt = this.getCommEvent(event, 'inform');
        super.info<infoType>(evt, listener);
        return this;
    }

    public ack(event: ICommEvent|string, listener: (callback: (e: Error) => void) => void): IComm {
        var evt = this.getCommEvent(event, 'confirm');
        super.ack(evt, listener);
        return this;
    }

    public answer<answerType>(
        event: ICommEvent|string, listener: (callback: (e: Error, answer?: answerType) => void) => void
    ): IComm {
        var evt = this.getCommEvent(event, 'ask');
        super.answer<answerType>(evt, listener);
        return this;
    }

    public respond<requestType, responseType>(
        event: ICommEvent|string,
        listener: (request: requestType, callback: (e: Error, response?: responseType) => void) => void)
    : IComm {
        var evt = this.getCommEvent(event, 'request');
        super.respond<requestType, responseType>(evt, listener);
        return this;
    }

    public onlyOnce(): IComm {
        super.onlyOnce();
        return this;
    }


    public dispose(callback?: () => void) {
        super.dispose(callback);
    }
}

export = Comm;
