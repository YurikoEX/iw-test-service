
import path = require('path');

import _ = require('lodash');
import io = require('socket.io');
import ioClient = require('socket.io-client');

var ioWildcard = require('socketio-wildcard')();

import IComm = require('../../interfaces/eventing/IComm');
import Comm = require('../../src/eventing/Comm');
import idHelper = require('../../src/helpers/idHelper');
import IAm = require('../../interfaces/whoIAm/IAm');
import Options = require('../../src/opts/Options');
import ICommEvent = require('../../interfaces/eventing/ICommEvent');
import IDependency = require('../../interfaces/workers/IDependency');
import ICollection = require('../../interfaces/collection/ICollection');
import IWorkerChild = require('../../interfaces/workers/IWorkerChild');
import IHttpWorker = require('../../interfaces/workers/IHttpWorker');

import Worker = require('../../src/workers/Worker');

import ISocketWorker = require('../../interfaces/workers/ISocketWorker');
import ISocketWorkerOpts = require('../../interfaces/opts/ISocketWorkerOpts');

class SocketWorker extends Worker implements ISocketWorker {
    public socketServer: any; //TODO: how do we type this?

    constructor(comm: IComm, service: IAm, opts?: ISocketWorkerOpts) {
        super([
            'iw-http'
        ], comm, service, {
            id: idHelper.newId(),
            name: 'iw-socket'
        });

        /**
         * TODO: remove... change interface as well
         * @type {{externalServiceUrlEnvVarPrefix: string}}
         */
        var defOpts: ISocketWorkerOpts = {
            externalServiceUrlEnvVarPrefix: 'iw_ext_srv_skt_url_'
        };
        this.opts = this.opts.beAdoptedBy<ISocketWorkerOpts>(defOpts, 'worker');
        this.opts.merge(opts);
    }

    public init(callback: (e: Error) => void) {
        if (!_.isUndefined(callback)) {
            process.nextTick(callback);
        }
    }

    private getExternalServiceUrl(service: string) {
        return process.env[this.opts.get<string>('externalServiceUrlEnvVarPrefix') + service];
    }

    public start(dependencies: ICollection<IDependency<IWorkerChild>>, callback?: (e: Error) => void) {
        var instance = this;
        dependencies.get({
            names: [ 'iw-http' ]
        }, (e, results: ICollection<IHttpWorker>) => {
            if (e === null) {
                /**
                 * TODO: Move to pcf service worker
                 */
                instance.comm.listen(instance.comm.prefix() + '.*.*.*.*', (...args: any[]) => {
                    var event = instance.getCommEmit(instance.comm.getLastEvent());
                    if (event.service !== instance.service.name) {
                        var serviceUrl = instance.getExternalServiceUrl(event.service);
                        var client = ioClient(serviceUrl);
                        client.emit.apply(client, [ event.getText() ].concat(args));
                    }
                });
                //END

                instance.socketServer = io(results.list()[0].httpServer.listener);
                instance.socketServer.use(ioWildcard);
                instance.socketServer.on('connection', (socket) => {
                    socket.on('error', (e) => {
                        //TODO
                        console.error(e);
                    });
                    socket.on('*', (event: any) => {
                        var eventName = event.data.shift();
                        var commEvent = instance.getCommEmit(eventName);
                        if (commEvent.service === instance.service.name) {
                            event.data.unshift(commEvent);
                            var method: Function = void 0;
                            switch (commEvent.method) {
                                case 'tell':
                                    method = instance.tell;
                                    break;
                                case 'inform':
                                    method = instance.inform;
                                    break;
                                case 'confirm':
                                    method = instance.confirm;
                                    break;
                                case 'ask':
                                    method = instance.ask;
                                    break;
                                case 'request':
                                    method = instance.request;
                                    break;
                            }
                            if (_.isUndefined(method)) {
                                instance.inform<Error>('error', new Error('unknown method: ' + commEvent.method));
                            }
                            else {
                                method.apply(instance, event.data);
                            }
                        }
                    });
                });
                instance.tell('ready');
            }
            else {
                instance.inform<Error>('error', e);
            }
            if (!_.isUndefined(callback)) {
                process.nextTick(() => {
                    callback(e);
                });
            }
        });
    }

    public dispose(callback?: () => void) {
        if (!_.isUndefined(this.socketServer)) {
            this.socketServer.close();
        }
        if (!_.isUndefined(callback)) {
            process.nextTick(() => {
                callback();
            });
        }
    }
}

export = SocketWorker;
